startEndSeq <- subset(startEndSeq, Ends >= monthSeqFirst & Starts <= monthSeqLast)
#	print(startEndSeq)
numYearsRaw <- length(startEndSeq$Ends)
# set up some vectors to keep track of years
good <- rep(0, numYearsRaw)
numDays <- rep(0, numYearsRaw)
midDecYear <- rep(0, numYearsRaw)
Qraw <- matrix(nrow = 366, ncol = numYearsRaw)
for(i in 1: numYearsRaw) {
startSeq <- startEndSeq$Starts[i]
endSeq <- startEndSeq$Ends[i]
startJulian <- getFirstJulian(startSeq)
# startJulian is the first julian day of the first month in the year being processed
# endJulian is the first julian day of the month right after the last month in the year being processed
endJulian <- getFirstJulian(endSeq + 1)
fullDuration <- endJulian - startJulian
#	cat("\n", i, startJulian, endJulian, fullDuration)
yearDaily <- localDaily[localDaily$MonthSeq >= startSeq & (localDaily$MonthSeq <= endSeq), ]
nDays <- length(yearDaily$Q)
if(nDays == fullDuration) {
good[i] <- 1
numDays[i] <- nDays
midDecYear[i] <- (yearDaily$DecYear[1] + yearDaily$DecYear[nDays]) / 2
Qraw[1:nDays,i] <- yearDaily$Q
}
else {numDays[i] <- NA
midDecYear[i] <- NA
}
}
# now we compress the matrix down to equal number of values in each column
j <- 0
numGoodYears <- sum(good)
#	print(good)
#	print(numGoodYears)
dayCounts <- ifelse(good==1, numDays, NA)
print(dayCounts)
lowDays <- min(dayCounts, na.rm = TRUE)
highDays <- max(dayCounts, na.rm = TRUE)
#	cat("\nminimum and maximum number of days in year", lowDays, highDays)
dimYears <- numGoodYears
dimDays <- lowDays
sortQ <- matrix(nrow = dimDays, ncol = dimYears)
time <- rep(0,dimYears)
for (i in 1:numYearsRaw){
if(good[i]==1) {
j <- j + 1
numD <- numDays[i]
#			cat("\n good year i, j, numD",i,j,numD)
x <- sort(Qraw[1:numD, i])
# separate odd numbers from even numbers of days
if(numD == lowDays) {sortQ[1:dimDays,j] <- x} else {
sortQ[1:dimDays,j] <- if(odd(numD)) leapOdd(x) else leapEven(x)
}
time[j] <- midDecYear[i]
#		cat("\n time in good year", time[j])
}
else {j <- j}
}
sortQList = list(sortQ,time)
return(sortQList)
}
#
trendSortQ <- function(Qsort, time){
# note requires packages zyp, rkt, and Kendall
nFreq <- dim(Qsort)[1]
#	cat("\n nFreq", nFreq)
nYears <- length(time)
#	cat("\n nYears",nYears)
results <- as.data.frame(matrix(ncol=9,nrow=nFreq))
colnames(results) <- c("slopeLog","slopePct","pValue","pValueAdj","tau","rho1","rho2","freq","z")
for(iRank in 1:nFreq){
mkOut <- rkt(time,log(Qsort[iRank,]))
results$slopeLog[iRank] <- mkOut$B
results$slopePct[iRank] <- 100 * (exp(mkOut$B) - 1)
results$pValue[iRank] <- mkOut$sl
outZYP <- zyp.zhang(log(Qsort[iRank,]),time)
results$pValueAdj[iRank] <- outZYP[6]
results$tau[iRank] <- mkOut$tau
# I don't actually use this information in the current outputs, but the code is there
# if one wanted to look at the serial correlation structure of the flow series
serial <- acf(log(Qsort[iRank,]), lag.max = 2, plot = FALSE)
results$rho1[iRank] <- serial$acf[2]
results$rho2[iRank] <- serial$acf[3]
frequency <- iRank / (nFreq + 1)
results$freq[iRank] <- frequency
results$z[iRank] <- qnorm(frequency)
}
return(results)
}
#
#
getFirstJulian <- function(monthSeq){
year <- 1850 + trunc((monthSeq - 1) / 12)
month <- monthSeq - 12 * (trunc((monthSeq-1)/12))
#	cat("\nyear, month",year, month)
charMonth <- ifelse(month<10,paste("0",as.character(month),sep=""),as.character(month))
theDate <- paste(year,"-",charMonth,"-01",sep="")
Julian1 <- as.numeric(julian(as.Date(theDate),origin=as.Date("1850-01-01")))
return(Julian1)
}
#
#
leapOdd <- function(x){
n <- length(x)
m <- n - 1
mid <- (n + 1) / 2
mid1 <- mid + 1
midMinus <- mid - 1
y <- rep(NA, m)
y[1:midMinus] <- x[1:midMinus]
y[mid:m] <- x[mid1:n]
return(y)}
#
#
leapEven <- function(x){
n <- length(x)
m <- n - 1
mid <- n / 2
y <- rep(NA, m)
mid1 <- mid + 1
mid2 <- mid + 2
midMinus <- mid - 1
y[1:midMinus] <- x[1:midMinus]
y[mid] <- (x[mid] + x[mid1]) / 2
y[mid1:m] <- x[mid2 : n]
return(y)
}
#
#
odd <- function(x) {if ((x %% 2) == 0) FALSE else TRUE}
#
#
calcWY <- function (df)
{
df$WaterYear <- as.integer(df$DecYear)
df$WaterYear[df$Month >= 10] <- df$WaterYear[df$Month >=
10] + 1
return(df)
}
#
#
calcCY <- function (df)
# computes climate year and adds it to the Daily data frame
{
df$ClimateYear <- as.integer(df$DecYear)
df$ClimateYear[df$Month >= 4] <- df$ClimateYear[df$Month >=
4] + 1
return(df)
}
#
#
#
plotFlowSingleKendall <- function (eList, istat, yearStart = NA, yearEnd = NA, qMax = NA,
printTitle = TRUE, tinyPlot = FALSE, customPar = FALSE, runoff = FALSE,
qUnit = 1, printStaName = TRUE, printPA = TRUE, printIstat = TRUE,
cex = 0.8, cex.axis = 1.1, cex.main = 1.1, lwd = 2, col = "black",
...)
{
localAnnualSeries <- makeAnnualSeries(eList)
localINFO <- getInfo(eList)
qActual <- localAnnualSeries[2, istat, ]
qSmooth <- localAnnualSeries[3, istat, ]
years <- localAnnualSeries[1, istat, ]
Q <- qActual
time <- years
LogQ <- log(Q)
mktFrame <- data.frame(time,LogQ)
mktFrame <- na.omit(mktFrame)
mktOut <- rkt(mktFrame$time,mktFrame$LogQ)
slope <- mktOut$B
slopePct <- 100 * (exp(slope)) - 100
slopePct <- format(slopePct,digits=2)
pValue <- mktOut$sl
pValue <- format(pValue,digits = 3)
### MK test goes here###
if (is.numeric(qUnit)) {
qUnit <- qConst[shortCode = qUnit][[1]]
}
else if (is.character(qUnit)) {
qUnit <- qConst[qUnit][[1]]
}
if (sum(c("paStart", "paLong", "window") %in% names(localINFO)) ==
3) {
paLong <- localINFO$paLong
paStart <- localINFO$paStart
window <- localINFO$window
}
else {
paLong <- 12
paStart <- 10
window <- 20
}
qFactor <- qUnit@qUnitFactor
qActual <- if (runoff)
qActual * 86.4/localINFO$drainSqKm
else qActual * qFactor
qSmooth <- if (runoff)
qSmooth * 86.4/localINFO$drainSqKm
else qSmooth * qFactor
localSeries <- data.frame(years, qActual, qSmooth)
localSeries <- if (is.na(yearStart))
localSeries
else subset(localSeries, years >= yearStart)
localSeries <- if (is.na(yearEnd))
localSeries
else subset(localSeries, years <= yearEnd)
yInfo <- generalAxis(x = qActual, maxVal = qMax, minVal = 0,
tinyPlot = tinyPlot)
xInfo <- generalAxis(x = localSeries$years, maxVal = yearEnd,
minVal = yearStart, padPercent = 0, tinyPlot = tinyPlot)
line1 <- if (printStaName)
localINFO$shortName
else ""
#  line2 <- if (printPA)
#    paste("\n", setSeasonLabelByUser(paStartInput = paStart,
#                                    paLongInput = paLong))
#  else ""
nameIstat <- c("minimum day", "7-day minimum", "30-day minimum",
"median daily", "mean daily", "30-day maximum", "7-day maximum",
"maximum day")
line2 <- if (printIstat)
paste("\n", nameIstat[istat])
else ""
line3 <- if(printPA)
paste("\nSlope estimate is ",slopePct,"% per year, Mann-Kendall p-value is ",pValue,sep="")
else ""
title <- if (printTitle)
paste(line1, line2, line3)
else ""
if (tinyPlot) {
yLab <- qUnit@qUnitTiny
title <- if (printTitle)
paste(nameIstat[istat])
else ""
}
else {
yLab <- qUnit@qUnitExpress
}
yLab <- if (runoff)
"Runoff in mm/day"
else yLab
genericEGRETDotPlot(x = localSeries$years, y = localSeries$qActual,
xlim = c(xInfo$bottom, xInfo$top), ylim = c(yInfo$bottom,
yInfo$top), xlab = "", ylab = yLab, customPar = customPar,
xTicks = xInfo$ticks, yTicks = yInfo$ticks, cex = cex,
plotTitle = title, cex.axis = cex.axis, cex.main = cex.main,
tinyPlot = tinyPlot, lwd = lwd, col = col, ...)
lines(localSeries$years, localSeries$qSmooth, lwd = lwd,
col = col)
}
library(EGRET)
library(rkt)
library(zyp)
library(Kendall)
library(zoo)
library(dataRetrieval)
#library(rloadest)
library(EGRETci)
library(foreach)
library(doParallel)
library(iterators)
library(zoo)
library(plotrix)
#dat <- read.table(textConnection("staid  start  end  name
#10336698  1979-10-01  2017-02-18   Third_Crk_nr_Crystal_Bay_NV
#10336700  1987-11-12  2017-01-09   Incline_Crk_nr_Crystal_Bay_NV
#103366993 1990-05-01  2011-03-31   Incline_Crk_above_Tyrol_Vil_nr_Incline_Vil_NV
#10336730  1989-11-16  2011-04-12   Glenbrook_Crk_at_Glenbrook_NV
#10336740  1988-10-01  2011-09-29   Logan_House_Crk_nr_Glenbrook_NV
#10336760  1992-10-01  2012-09-29   Edgewood_Crk_at_Stateline_NV
#10336780  1977-10-01  2017-04-17   Trout_Crk_nr_Tahoe_Valley_CA
#10336775  1990-06-01  2011-10-05   Trout_Crk_at_Pioneer_Trail_nr_S_Lake_Tahoe_CA
#10336770  1990-05-22  2011-03-31   Trout_Crk_at_USFS_Road_12N01_nr_Meyers_CA
#10336610  1980-03-02  2016-11-20   Up_Truckee_Rv_at_S_Lake_Tahoe_CA
#103366092 1990-06-01  2011-06-30   Up_Truckee_Rv_at_Hwy_50_above_Meyers_CA
#10336580  1990-05-12  2011-09-29   Up_Truckee_Rv_at_S_Up_Truckee_Road_nr_Meyers_CA
#10336645  1980-07-07  2017-01-09   General_Crk_nr_Meeks_Bay_CA
#10336660  1974-10-01  2016-11-05   Blackwood_Crk_nr_Tahoe_City_CA
#10336676  1972-10-01  2017-01-07   Ward_Crk_at_Hwy_89_nr_Tahoe_Pines_CA
#10336674  1991-10-01  2011-11-01   Ward_Crk_blw_confluence_nr_Tahoe_City_CA
#10337500  1909-01-02  2017-01-26   Truckee_Rv_at_Tahoe_City_CA"), header=TRUE, colClasses=c('character','Date','Date','character'))
# Omitted because of a short recordset
# ------------------------------------
# 103367592 - Eagle Rock Creek near Stateline, NV
# 10336790  - Trout Creek at South Lake Tahoe, CA
setwd('/users/joed/Documents/Documents19/Biogeochemistry_2019/Freeport_QuantileKendall')
#for (i in (1:nrow(dat))){
#   sta   <- dat[i,'staid']
#    param <- "00060"
#    start <- dat[i,'start']
#    end   <- dat[i,'end']
#    fileName <- paste0(dat[i,'name'],".pdf")
sta <- "11447650"
param <- "00060"
start <- "1948-10-01"
end   <- "2019-04-27"
fileName <- "SacFreeport.pdf"
paStart <- 4
paLong <- 12
# Bob Hirsch: note, for annual analyses it is best to use paStart = 4, paLong = 12
# but for seasonal analyses pick the combination of paStart and paLong that
# is appropriate for your work
# for this next command I had to figure out the best start and end dates to get full water years
filePath <- '/users/joed/Documents/Documents19/Biogeochemistry_2019/Freeport_QuantileKendall/'
fileName <- "FreeportDaily_cfs.csv"
#Daily <- readNWISDaily(sta,param,startDate = start, endDate = end)
Daily <-readUserDaily(filePath, fileName, hasHeader = TRUE, separator = ",", qUnit = 1)
# If there are NA's in Daily$Q, functions won't work, replace with interpolated values
if(any(is.na(Daily$Q))){
x <- zoo(Daily$Q,Daily$Date)
x <- as.ts(x)
x <- na.interp(x)
Daily$Q <- x
# Alternative for replace with 0.1% of the mean
# Daily[is.na(Daily$Q),'Q'] <- mean(Daily$Q, na.rm=TRUE) * 0.001
}
INFO  <- readNWISInfo(sta,param,interactive=FALSE)
eList <- as.egret(INFO,Daily)
eList <- setPA(eList,paStart = paStart, paLong = paLong, window = 30)
#old width and height were 12 and 10
pdf(file = "Freeportquantile.pdf", width =6, height = 5)
par(mfrow=c(2,2))
plotFlowSingleKendall(eList, istat = 1, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65,cex.lab=0.75,col='blue')
plotFlowSingleKendall(eList, istat = 4, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65, cex.lab=0.75)
plotFlowSingleKendall(eList, istat = 8, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65, cex.lab=0.75)
plotFlowSingleKendall(eList, istat = 5, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65, cex.lab=0.75)
dev.off()
# Be sure to paste the functions stored in "...\LTIMP_TA\LTIMP_TA2\Quantile_Kendall_AnalysisfunctionsForQuantileKendall.R"
# before attempting to run the following commands
# --------------------------------------------------------------------------------------------------------------------------
eList   <- setPA(eList, paStart = paStart, paLong = paLong, window = 30)
v       <- makeSortQ(eList)
sortQ   <- v[[1]]
time    <- v[[2]]
results <- trendSortQ(sortQ, time)
pvals   <- c(0.001,0.01,0.05,0.1,0.25,0.5,0.75,0.9,0.95,0.99,0.999)
zvals   <- qnorm(pvals)
name    <- eList$INFO$shortName
ymax    <- trunc(max(results$slopePct)*10)
ymax    <- max(ymax + 2, 5)
ymin    <- floor(min(results$slopePct)*10)
ymin    <- min(ymin - 2, -5)
yrange  <- c(ymin/10, ymax/10)
yticks  <- axisTicks(yrange, log = FALSE)
p       <- results$pValueAdj
color   <- ifelse(p <= 0.1,"black","snow3")
color   <- ifelse(p < 0.05, "red", color)
pvals   <- c(0.001,0.01,0.05,0.1,0.25,0.5,0.75,0.9,0.95,0.99,0.999)
zvals   <- qnorm(pvals)
name    <- paste(eList$INFO$shortName,
"\nAdjusted Mann Kendall significance",
"  ", "1948-2019")
# old width and height were 8 and 6
#filename2 <- paste0('Mann_Kendall_',dat[i,4],'.pdf')
filename2 <- 'SacFreeport.pdf'
pdf(file = filename2, width = 6, height = 4)
plot(results$z,results$slopePct,
col = color,
pch = 20,
cex = 1.0,
xlab = "Daily non-exceedance probability",
ylab = "Trend slope in percent per year",
xlim = c(-3.2, 3.2),
ylim = yrange,
las = 1,
tck = 0.02,
cex.lab = 1.2,
cex.axis = 1.2,
axes = FALSE,
frame.plot=TRUE)
mtext(name, side =3, line = 1.5, cex = 1.2)
axis(1,at=zvals,labels=pvals, las = 1, tck = 0.02)
axis(2,at=yticks,labels = TRUE, las = 1, tck = 0.02)
axis(3,at=zvals,labels=FALSE, las = 1, tck=0.02)
axis(4,at=yticks,labels = FALSE, tick = TRUE, tck = 0.02)
abline(h=0,col="red")
legend("bottomright",c("> 0.1","0.05 - 0.1","< 0.05"),
col = c("snow3","black","red"),pch = 20,
pt.cex=1.0, cex = 1.0, bg='white', bty='n')
dev.off()
#}
library(EGRET)
library(rkt)
library(zyp)
library(Kendall)
library(zoo)
library(dataRetrieval)
library(rloadest)
library(EGRETci)
library(foreach)
library(doParallel)
library(iterators)
library(zoo)
library(plotrix)
#dat <- read.table(textConnection("staid  start  end  name
#10336698  1979-10-01  2017-02-18   Third_Crk_nr_Crystal_Bay_NV
#10336700  1987-11-12  2017-01-09   Incline_Crk_nr_Crystal_Bay_NV
#103366993 1990-05-01  2011-03-31   Incline_Crk_above_Tyrol_Vil_nr_Incline_Vil_NV
#10336730  1989-11-16  2011-04-12   Glenbrook_Crk_at_Glenbrook_NV
#10336740  1988-10-01  2011-09-29   Logan_House_Crk_nr_Glenbrook_NV
#10336760  1992-10-01  2012-09-29   Edgewood_Crk_at_Stateline_NV
#10336780  1977-10-01  2017-04-17   Trout_Crk_nr_Tahoe_Valley_CA
#10336775  1990-06-01  2011-10-05   Trout_Crk_at_Pioneer_Trail_nr_S_Lake_Tahoe_CA
#10336770  1990-05-22  2011-03-31   Trout_Crk_at_USFS_Road_12N01_nr_Meyers_CA
#10336610  1980-03-02  2016-11-20   Up_Truckee_Rv_at_S_Lake_Tahoe_CA
#103366092 1990-06-01  2011-06-30   Up_Truckee_Rv_at_Hwy_50_above_Meyers_CA
#10336580  1990-05-12  2011-09-29   Up_Truckee_Rv_at_S_Up_Truckee_Road_nr_Meyers_CA
#10336645  1980-07-07  2017-01-09   General_Crk_nr_Meeks_Bay_CA
#10336660  1974-10-01  2016-11-05   Blackwood_Crk_nr_Tahoe_City_CA
#10336676  1972-10-01  2017-01-07   Ward_Crk_at_Hwy_89_nr_Tahoe_Pines_CA
#10336674  1991-10-01  2011-11-01   Ward_Crk_blw_confluence_nr_Tahoe_City_CA
#10337500  1909-01-02  2017-01-26   Truckee_Rv_at_Tahoe_City_CA"), header=TRUE, colClasses=c('character','Date','Date','character'))
# Omitted because of a short recordset
# ------------------------------------
# 103367592 - Eagle Rock Creek near Stateline, NV
# 10336790  - Trout Creek at South Lake Tahoe, CA
setwd('/users/joed/Documents/Documents19/Biogeochemistry_2019/Freeport_QuantileKendall')
#for (i in (1:nrow(dat))){
#   sta   <- dat[i,'staid']
#    param <- "00060"
#    start <- dat[i,'start']
#    end   <- dat[i,'end']
#    fileName <- paste0(dat[i,'name'],".pdf")
sta <- "11447650"
param <- "00060"
start <- "1948-10-01"
end   <- "2019-04-27"
fileName <- "SacFreeport.pdf"
paStart <- 4
paLong <- 12
# Bob Hirsch: note, for annual analyses it is best to use paStart = 4, paLong = 12
# but for seasonal analyses pick the combination of paStart and paLong that
# is appropriate for your work
# for this next command I had to figure out the best start and end dates to get full water years
filePath <- '/users/joed/Documents/Documents19/Biogeochemistry_2019/Freeport_QuantileKendall/'
fileName <- "FreeportDaily_cfs.csv"
#Daily <- readNWISDaily(sta,param,startDate = start, endDate = end)
Daily <-readUserDaily(filePath, fileName, hasHeader = TRUE, separator = ",", qUnit = 1)
# If there are NA's in Daily$Q, functions won't work, replace with interpolated values
if(any(is.na(Daily$Q))){
x <- zoo(Daily$Q,Daily$Date)
x <- as.ts(x)
x <- na.interp(x)
Daily$Q <- x
# Alternative for replace with 0.1% of the mean
# Daily[is.na(Daily$Q),'Q'] <- mean(Daily$Q, na.rm=TRUE) * 0.001
}
INFO  <- readNWISInfo(sta,param,interactive=FALSE)
eList <- as.egret(INFO,Daily)
eList <- setPA(eList,paStart = paStart, paLong = paLong, window = 30)
#old width and height were 12 and 10
pdf(file = "Freeportquantile.pdf", width =6, height = 5)
par(mfrow=c(2,2))
plotFlowSingleKendall(eList, istat = 1, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65,cex.lab=0.75,col='blue')
plotFlowSingleKendall(eList, istat = 4, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65, cex.lab=0.75)
plotFlowSingleKendall(eList, istat = 8, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65, cex.lab=0.75)
plotFlowSingleKendall(eList, istat = 5, qUnit = 2,cex=0.5,cex.axis = 0.65, cex.main = 0.65, cex.lab=0.75)
dev.off()
# Be sure to paste the functions stored in "...\LTIMP_TA\LTIMP_TA2\Quantile_Kendall_AnalysisfunctionsForQuantileKendall.R"
# before attempting to run the following commands
# --------------------------------------------------------------------------------------------------------------------------
eList   <- setPA(eList, paStart = paStart, paLong = paLong, window = 30)
v       <- makeSortQ(eList)
sortQ   <- v[[1]]
time    <- v[[2]]
results <- trendSortQ(sortQ, time)
pvals   <- c(0.001,0.01,0.05,0.1,0.25,0.5,0.75,0.9,0.95,0.99,0.999)
zvals   <- qnorm(pvals)
name    <- eList$INFO$shortName
ymax    <- trunc(max(results$slopePct)*10)
ymax    <- max(ymax + 2, 5)
ymin    <- floor(min(results$slopePct)*10)
ymin    <- min(ymin - 2, -5)
yrange  <- c(ymin/10, ymax/10)
yticks  <- axisTicks(yrange, log = FALSE)
p       <- results$pValueAdj
color   <- ifelse(p <= 0.1,"black","snow3")
color   <- ifelse(p < 0.05, "red", color)
pvals   <- c(0.001,0.01,0.05,0.1,0.25,0.5,0.75,0.9,0.95,0.99,0.999)
zvals   <- qnorm(pvals)
name    <- paste(eList$INFO$shortName,
"\nAdjusted Mann Kendall significance",
"  ", "1948-2019")
# old width and height were 8 and 6
#filename2 <- paste0('Mann_Kendall_',dat[i,4],'.pdf')
filename2 <- 'SacFreeport.pdf'
pdf(file = filename2, width = 6, height = 4)
plot(results$z,results$slopePct,
col = color,
pch = 20,
cex = 1.0,
xlab = "Daily non-exceedance probability",
ylab = "Trend slope in percent per year",
xlim = c(-3.2, 3.2),
ylim = yrange,
las = 1,
tck = 0.02,
cex.lab = 1.2,
cex.axis = 1.2,
axes = FALSE,
frame.plot=TRUE)
mtext(name, side =3, line = 1.5, cex = 1.2)
axis(1,at=zvals,labels=pvals, las = 1, tck = 0.02)
axis(2,at=yticks,labels = TRUE, las = 1, tck = 0.02)
axis(3,at=zvals,labels=FALSE, las = 1, tck=0.02)
axis(4,at=yticks,labels = FALSE, tick = TRUE, tck = 0.02)
abline(h=0,col="red")
legend("bottomright",c("> 0.1","0.05 - 0.1","< 0.05"),
col = c("snow3","black","red"),pch = 20,
pt.cex=1.0, cex = 1.0, bg='white', bty='n')
dev.off()
#}
